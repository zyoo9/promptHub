# PromptHub - 简化版提示词版本管理平台技术设计文档

## 📋 项目概述

PromptHub是一个简化的提示词版本管理平台，采用三层结构：**项目 → 分支 → 版本**。无需用户注册登录，支持随意创建项目和分支，每个分支独立进行版本管理。

## 🎯 核心需求

### 功能需求
- **项目管理**: 创建、删除、重命名项目
- **分支管理**: 在项目下创建、删除、切换分支
- **版本控制**: 分支内的提交、历史记录、回滚功能
- **可视化**: 分支图、提交历史、差异对比
- **按钮操作**: 所有操作都通过UI按钮完成
- **本地存储**: 所有数据存储在本地，无需账户

### 非功能需求
- **简单易用**: 零学习成本，直接使用
- **性能**: 快速响应，流畅操作
- **可用性**: 简洁直观的界面
- **数据安全**: 本地数据持久化

## 🏗️ 系统架构

### 整体架构图
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端 (Next.js) │────│   API Routes    │────│   MySQL数据库    │
│                 │    │                 │    │                 │
│ - React组件     │    │ - 项目管理      │    │ - 项目数据      │
│ - 状态管理      │    │ - 分支管理      │    │ - 分支数据      │
│ - 路由管理      │    │ - 版本控制      │    │ - 版本数据      │
│ - UI交互        │    │ - 文件操作      │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 技术栈选择

#### 前端技术栈
- **框架**: Next.js 14 (App Router)
  - 服务端渲染支持
  - 内置API Routes
  - 简单部署
  
- **UI框架**: 
  - Tailwind CSS: 原子化CSS框架
  - Shadcn/ui: 高质量组件库
  - Lucide React: 图标库
  
- **状态管理**: Zustand
  - 轻量级状态管理
  - TypeScript友好
  
- **可视化**: 
  - React Flow: 分支图可视化
  - Monaco Editor: 代码编辑器
  
- **其他工具**:
  - React Hook Form: 表单管理
  - diff库: 文本差异对比

#### 后端技术栈
- **运行时**: Node.js + TypeScript
- **框架**: Next.js API Routes
- **数据库**: MySQL 8.0+
- **ORM**: Prisma
  - 类型安全的数据库客户端
  - 自动生成TypeScript类型
  - 数据库迁移管理

## 🗄️ 数据库设计

### ER图
```
Projects ||--o{ Branches : contains
Branches ||--o{ Commits : contains  
Commits }o--|| Commits : parent_of
```

### 数据表结构

#### 项目表 (projects)
```sql
CREATE TABLE projects (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    default_branch VARCHAR(100) DEFAULT 'main',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_name (name)
);
```

#### 分支表 (branches)
```sql
CREATE TABLE branches (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    project_id VARCHAR(36) NOT NULL,
    is_default BOOLEAN DEFAULT FALSE,
    last_commit_id VARCHAR(36),
    created_from_commit_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY (last_commit_id) REFERENCES commits(id) ON DELETE SET NULL,
    FOREIGN KEY (created_from_commit_id) REFERENCES commits(id) ON DELETE SET NULL,
    UNIQUE KEY unique_branch_per_project (project_id, name),
    INDEX idx_project_id (project_id),
    INDEX idx_last_commit_id (last_commit_id)
);
```

#### 提交表 (commits)
```sql
CREATE TABLE commits (
    id VARCHAR(36) PRIMARY KEY,
    message VARCHAR(500) NOT NULL,
    content LONGTEXT NOT NULL,
    branch_id VARCHAR(36) NOT NULL,
    parent_commit_id VARCHAR(36),
    commit_hash VARCHAR(64) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (branch_id) REFERENCES branches(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_commit_id) REFERENCES commits(id) ON DELETE SET NULL,
    INDEX idx_branch_id (branch_id),
    INDEX idx_commit_hash (commit_hash),
    INDEX idx_created_at (created_at)
);
```

### Prisma数据模型
```prisma
// schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Project {
  id             String   @id @default(uuid())
  name           String   @unique
  description    String?  @db.Text
  defaultBranch  String   @default("main") @map("default_branch")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")
  
  branches       Branch[]
  
  @@map("projects")
  @@index([name])
}

model Branch {
  id                  String   @id @default(uuid())
  name                String
  projectId           String   @map("project_id")
  isDefault           Boolean  @default(false) @map("is_default")
  lastCommitId        String?  @map("last_commit_id")
  createdFromCommitId String?  @map("created_from_commit_id")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")
  
  project             Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  lastCommit          Commit?  @relation("BranchLastCommit", fields: [lastCommitId], references: [id])
  createdFromCommit   Commit?  @relation("BranchCreatedFrom", fields: [createdFromCommitId], references: [id])
  commits             Commit[] @relation("BranchCommits")
  
  @@map("branches")
  @@unique([projectId, name], name: "unique_branch_per_project")
  @@index([projectId])
  @@index([lastCommitId])
}

model Commit {
  id             String   @id @default(uuid())
  message        String   @db.VarChar(500)
  content        String   @db.LongText
  branchId       String   @map("branch_id")
  parentCommitId String?  @map("parent_commit_id")
  commitHash     String   @unique @map("commit_hash") @db.VarChar(64)
  createdAt      DateTime @default(now()) @map("created_at")
  
  branch         Branch   @relation("BranchCommits", fields: [branchId], references: [id], onDelete: Cascade)
  parentCommit   Commit?  @relation("CommitParent", fields: [parentCommitId], references: [id])
  childCommits   Commit[] @relation("CommitParent")
  
  // 反向关系
  branchesLastCommit    Branch[] @relation("BranchLastCommit")
  branchesCreatedFrom   Branch[] @relation("BranchCreatedFrom")
  
  @@map("commits")
  @@index([branchId])
  @@index([commitHash])
  @@index([createdAt])
}
```

## 🔌 API接口设计

### 项目管理接口
```typescript
// 获取所有项目列表
GET /api/projects

// 创建项目
POST /api/projects
{
  name: string;
  description?: string;
}

// 获取项目详情
GET /api/projects/[id]

// 更新项目
PUT /api/projects/[id]
{
  name?: string;
  description?: string;
}

// 删除项目
DELETE /api/projects/[id]
```

### 分支管理接口
```typescript
// 获取项目的分支列表
GET /api/projects/[id]/branches

// 创建分支
POST /api/projects/[id]/branches
{
  name: string;
  sourceCommitId?: string; // 基于某个commit创建分支，不传则基于默认分支最新commit
}

// 获取分支详情（包含最新内容）
GET /api/projects/[id]/branches/[branchName]

// 获取分支当前内容
GET /api/projects/[id]/branches/[branchName]/content

// 删除分支
DELETE /api/projects/[id]/branches/[branchName]
```

### 版本管理接口
```typescript
// 获取分支的提交历史
GET /api/projects/[id]/branches/[branchName]/commits

// 创建提交(保存版本)
POST /api/projects/[id]/branches/[branchName]/commits
{
  message: string;
  content: string;
}

// 获取提交详情
GET /api/projects/[id]/branches/[branchName]/commits/[commitId]

// 回滚到指定提交
POST /api/projects/[id]/branches/[branchName]/commits/[commitId]/revert

// 获取两个提交之间的差异
GET /api/projects/[id]/branches/[branchName]/commits/[commitId]/diff?compare=[otherCommitId]
```

## 💼 核心业务流程

### 项目初始化流程
```typescript
// 1. 创建项目
const project = await createProject({
  name: "AI写作助手",
  description: "用于生成文章的提示词集合"
});

// 2. 自动创建默认分支和初始提交
const defaultBranch = await createBranch(project.id, {
  name: "main",
  isDefault: true
});

const initialCommit = await createCommit(project.id, "main", {
  message: "初始提交",
  content: "// 在这里编写你的提示词\n"
});

// 3. 更新分支的最新commit
await updateBranch(project.id, "main", {
  lastCommitId: initialCommit.id
});
```

### 分支创建流程
```typescript
// 1. 基于现有commit创建新分支
const newBranch = await createBranch(project.id, {
  name: "feature/新功能",
  sourceCommitId: "existing-commit-id"
});

// 2. 新分支自动继承源commit的内容
// 3. 设置新分支的last_commit_id为源commit
```

### 版本保存流程
```typescript
// 1. 用户在编辑器中修改内容
// 2. 自动保存到草稿状态
// 3. 用户点击"提交"按钮
const newCommit = await createCommit(project.id, branchName, {
  message: "优化写作风格",
  content: updatedContent
});

// 4. 更新分支的最新commit
await updateBranch(project.id, branchName, {
  lastCommitId: newCommit.id
});
```

### 版本回滚流程
```typescript
// 1. 用户选择要回滚到的commit
// 2. 创建新的commit，内容为目标commit的内容
const revertCommit = await createCommit(project.id, branchName, {
  message: `回滚到 ${targetCommit.message}`,
  content: targetCommit.content,
  parentCommitId: currentCommit.id
});

// 3. 更新分支指针
await updateBranch(project.id, branchName, {
  lastCommitId: revertCommit.id
});
```

## 🎨 界面设计

### 页面结构
```
├── / (项目列表首页)
├── /projects/new (创建项目)
├── /projects/[id] (项目详情)
│   ├── /branches (分支列表)
│   ├── /branches/[name] (分支详情)
│   ├── /branches/[name]/edit (编辑提示词)
│   ├── /branches/[name]/history (版本历史)
│   └── /branches/[name]/compare (版本对比)
```

### 核心组件设计

#### 1. 项目仪表板
- **功能**: 显示所有项目列表
- **组件**: 
  - 项目卡片网格
  - 搜索过滤器
  - 创建项目按钮
  - 最近活动显示

#### 2. 分支管理界面
- **功能**: 项目内的分支管理
- **组件**:
  - 分支列表
  - 创建分支按钮
  - 分支切换
  - 分支删除操作

#### 3. 提示词编辑器
- **功能**: 编辑和预览提示词
- **技术**: Monaco Editor
- **特性**:
  - 语法高亮
  - 实时预览
  - 自动保存
  - 全屏编辑

#### 4. 版本历史视图
- **功能**: 显示分支的版本历史
- **组件**:
  - 提交时间线
  - 版本差异对比
  - 回滚操作按钮
  - 版本详情预览

### UI/UX设计原则

#### 设计语言
- **风格**: 现代简洁，类似GitHub
- **色彩**: 蓝色主题，高对比度
- **字体**: 系统字体栈
- **图标**: Lucide React图标集

#### 交互设计
- **操作反馈**: 所有操作都有明确的成功/失败反馈
- **加载状态**: 骨架屏和进度指示器
- **错误处理**: 友好的错误信息和建议
- **快捷操作**: 键盘快捷键支持

## 🔐 数据安全

### 数据保护
- **输入验证**: 严格的输入验证和清理
- **SQL注入防护**: Prisma ORM参数化查询
- **XSS防护**: 输入转义和内容过滤

### 数据持久化
- **自动保存**: 定期自动保存编辑内容
- **数据备份**: 定期数据库备份
- **版本追踪**: 完整的变更历史记录

## 📊 性能优化

### 前端优化
- **代码分割**: 路由级别的懒加载
- **缓存策略**: React Query数据缓存
- **图片优化**: Next.js Image组件
- **CDN**: 静态资源CDN分发

### 后端优化
- **数据库优化**: 
  - 合理的索引设计
  - 查询优化
  - 连接池管理
- **缓存策略**: Redis缓存热点数据
- **API优化**: 
  - GraphQL按需查询
  - 数据分页
  - 响应压缩

### 数据库优化
- **索引策略**: 针对查询模式建立索引
- **分表分库**: 大数据量时的水平分割
- **读写分离**: 主从复制架构
- **监控告警**: 数据库性能监控

## 🚀 部署架构

### 开发环境
```
开发者本地 → Docker容器 → MySQL本地实例
```

### 生产环境  
```
用户 → CDN → 负载均衡器 → Next.js应用集群 → MySQL主从集群
                         ↓
                    Redis缓存集群
```

### 技术栈部署
- **容器化**: Docker + Docker Compose
- **编排**: Kubernetes (可选)
- **CI/CD**: GitHub Actions
- **监控**: Prometheus + Grafana
- **日志**: ELK Stack

## 📈 监控告警

### 应用监控
- **性能指标**: 响应时间、吞吐量、错误率
- **用户体验**: Core Web Vitals
- **业务指标**: 用户活跃度、仓库使用情况

### 基础设施监控
- **服务器**: CPU、内存、磁盘、网络
- **数据库**: 连接数、查询性能、锁等待
- **缓存**: 命中率、内存使用

### 告警策略
- **分级告警**: P0(紧急) → P3(一般)
- **通知渠道**: 邮件、短信、钉钉
- **自动恢复**: 简单故障自动处理

## 🔄 版本控制算法

### Git-like版本控制实现

#### 1. 提交(Commit)算法
```typescript
interface CommitAlgorithm {
  // 创建提交
  createCommit(content: string, message: string, parentId?: string): Commit
  
  // 计算内容哈希
  calculateHash(content: string, timestamp: number): string
  
  // 验证提交链
  validateCommitChain(commits: Commit[]): boolean
}

// 具体实现
class CommitService implements CommitAlgorithm {
  async createCommit(branchId: string, content: string, message: string): Promise<Commit> {
    const timestamp = Date.now();
    const hash = this.calculateHash(content, timestamp);
    
    // 获取分支当前最新commit作为parent
    const branch = await this.getBranch(branchId);
    const parentCommitId = branch.last_commit_id;
    
    const commit = await this.db.commits.create({
      data: {
        id: generateUUID(),
        message,
        content,
        branch_id: branchId,
        parent_commit_id: parentCommitId,
        commit_hash: hash,
        created_at: new Date(timestamp)
      }
    });
    
    // 更新分支的最新commit指针
    await this.db.branches.update({
      where: { id: branchId },
      data: { last_commit_id: commit.id }
    });
    
    return commit;
  }
  
  calculateHash(content: string, timestamp: number): string {
    const crypto = require('crypto');
    const data = `${content}${timestamp}`;
    return crypto.createHash('sha256').update(data).digest('hex');
  }
  
  async validateCommitChain(branchId: string): Promise<boolean> {
    const commits = await this.db.commits.findMany({
      where: { branch_id: branchId },
      orderBy: { created_at: 'asc' }
    });
    
    // 验证每个commit的parent关系
    for (let i = 1; i < commits.length; i++) {
      if (commits[i].parent_commit_id !== commits[i-1].id) {
        return false;
      }
    }
    return true;
  }
}
```

#### 2. 分支(Branch)管理
```typescript
interface BranchAlgorithm {
  // 创建分支
  createBranch(name: string, sourceCommitId: string): Branch
  
  // 分支切换
  checkoutBranch(branchId: string): BranchState
  
  // 获取分支差异
  getBranchDiff(branch1: string, branch2: string): Diff[]
}
```

#### 3. 合并(Merge)算法
```typescript
interface MergeAlgorithm {
  // 三路合并
  threeWayMerge(base: string, source: string, target: string): MergeResult
  
  // 冲突检测
  detectConflicts(source: string, target: string): Conflict[]
  
  // 自动合并
  autoMerge(sourceCommit: string, targetCommit: string): MergeResult
}
```

#### 4. 差异对比算法
```typescript
interface DiffAlgorithm {
  // Myers差异算法
  calculateDiff(oldText: string, newText: string): DiffLine[]
  
  // 单词级差异
  wordLevelDiff(oldText: string, newText: string): WordDiff[]
  
  // 语义差异(AI增强)
  semanticDiff(oldPrompt: string, newPrompt: string): SemanticDiff[]
}
```

## 🧪 测试策略

### 测试金字塔
```
        E2E测试 (10%)
    ↗               ↖
集成测试 (20%)      API测试 (20%)  
    ↗                       ↖
        单元测试 (50%)
```

### 测试工具
- **单元测试**: Jest + React Testing Library
- **集成测试**: Supertest
- **E2E测试**: Playwright
- **性能测试**: K6
- **安全测试**: OWASP ZAP

### 测试覆盖率
- **代码覆盖率**: >90%
- **分支覆盖率**: >85%
- **功能覆盖率**: >95%

## 📝 开发规范

### 代码规范
- **TypeScript**: 严格模式
- **ESLint**: Airbnb配置
- **Prettier**: 代码格式化
- **Husky**: Git hooks
- **Conventional Commits**: 提交信息规范

### 文档规范
- **API文档**: OpenAPI 3.0
- **代码注释**: TSDoc规范
- **README**: 项目说明
- **CHANGELOG**: 版本变更日志

## 🎛️ 配置管理

### 环境配置
```bash
# .env.local (开发环境)
DATABASE_URL="mysql://root:password@localhost:3306/prompthub_dev"
NEXTAUTH_SECRET="your-secret-key"
NEXTAUTH_URL="http://localhost:3000"

# .env.production (生产环境)  
DATABASE_URL="mysql://user:password@prod-host:3306/prompthub_prod"
NEXTAUTH_SECRET="production-secret-key"
NEXTAUTH_URL="https://your-domain.com"
```

### Next.js配置
```javascript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    appDir: true,
  },
  env: {
    DATABASE_URL: process.env.DATABASE_URL,
  }
}

module.exports = nextConfig
```

### Package.json脚本
```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build", 
    "start": "next start",
    "lint": "next lint",
    "db:push": "prisma db push",
    "db:studio": "prisma studio",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:seed": "tsx prisma/seed.ts"
  }
}
```

### API实现示例
```typescript
// app/api/projects/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function GET() {
  try {
    const projects = await prisma.project.findMany({
      include: {
        branches: {
          where: { isDefault: true },
          include: {
            lastCommit: true
          }
        }
      },
      orderBy: { updatedAt: 'desc' }
    });
    
    return NextResponse.json(projects);
  } catch (error) {
    return NextResponse.json(
      { error: '获取项目列表失败' },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  try {
    const { name, description } = await request.json();
    
    // 创建项目
    const project = await prisma.project.create({
      data: { name, description }
    });
    
    // 创建默认分支
    const defaultBranch = await prisma.branch.create({
      data: {
        name: 'main',
        projectId: project.id,
        isDefault: true
      }
    });
    
    // 创建初始提交
    const initialCommit = await prisma.commit.create({
      data: {
        message: '初始提交',
        content: '// 在这里编写你的提示词\n',
        branchId: defaultBranch.id,
        commitHash: generateHash('// 在这里编写你的提示词\n' + Date.now())
      }
    });
    
    // 更新分支的最新提交
    await prisma.branch.update({
      where: { id: defaultBranch.id },
      data: { lastCommitId: initialCommit.id }
    });
    
    return NextResponse.json(project, { status: 201 });
  } catch (error) {
    return NextResponse.json(
      { error: '创建项目失败' },
      { status: 500 }
    );
  }
}
```

## 📋 项目计划

### 第一阶段 (基础功能 - 3周)
- [ ] 项目管理(创建、删除、列表)
- [ ] 基础界面搭建
- [ ] 数据库设计和实现
- [ ] 基础API接口

### 第二阶段 (版本控制 - 4周)  
- [ ] 分支管理功能
- [ ] 提交和版本历史
- [ ] 差异对比功能
- [ ] 回滚操作

### 第三阶段 (编辑器 - 3周)
- [ ] Monaco编辑器集成
- [ ] 实时预览功能
- [ ] 自动保存机制
- [ ] 快捷键支持

### 第四阶段 (优化完善 - 2周)
- [ ] 性能优化
- [ ] 界面美化
- [ ] 错误处理
- [ ] 部署上线

## 🔮 未来扩展

### 功能增强
- **智能提示**: AI辅助编写提示词
- **模板管理**: 常用提示词模板
- **搜索功能**: 全文搜索和标签分类
- **导入导出**: 支持多种格式导入导出

### 高级功能
- **团队协作**: 多人协作编辑
- **API集成**: 与AI模型API集成测试
- **版本标签**: 版本标签和发布管理
- **统计分析**: 使用情况统计

### 生态扩展
- **浏览器插件**: 快捷访问和使用
- **CLI工具**: 命令行操作工具
- **移动应用**: 移动端查看和编辑
- **第三方集成**: 与其他工具集成

---

*本文档将随着项目进展持续更新和完善*
